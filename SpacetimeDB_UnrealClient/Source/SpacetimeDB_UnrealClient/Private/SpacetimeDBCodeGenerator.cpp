// Copyright Epic Games, Inc. All Rights Reserved.

#include "SpacetimeDBCodeGenerator.h"
#include "HAL/FileManager.h"
#include "Misc/FileHelper.h"
#include "Engine/Blueprint.h"
#include "Engine/BlueprintGeneratedClass.h"
#include "GameFramework/Actor.h"
#include "Components/ActorComponent.h"
#include "GameFramework/Character.h"
#include "GameFramework/Pawn.h"
#include "GameFramework/Controller.h"

#include "Components/SkeletalMeshComponent.h"
#include "Components/SceneComponent.h"
#include "GameFramework/PlayerController.h"
#include "UObject/UnrealType.h"
#include "UObject/UObjectIterator.h"
#include "UObject/Class.h"
#include "Misc/PackageName.h"
#include "Misc/Paths.h"

USpacetimeDBCodeGenerator::USpacetimeDBCodeGenerator()
    : NextClassId(100) // Start at 100 to leave space for hardcoded core classes
{
}

void USpacetimeDBCodeGenerator::Initialize(FSubsystemCollectionBase& Collection)
{
    Super::Initialize(Collection);
    
    // Initialize with core class mappings
    // IMPORTANT: This generator is the SINGLE SOURCE OF TRUTH for class IDs!
    // Both core engine classes (IDs 1-99) and game-specific classes (IDs 100+) 
    // are defined here and exported to the server module.
    ClassIdMap.Add(TEXT("/Script/CoreUObject.Object"), 1);
    ClassIdMap.Add(TEXT("/Script/Engine.ActorComponent"), 2);
    ClassIdMap.Add(TEXT("/Script/Engine.SceneComponent"), 3);
    ClassIdMap.Add(TEXT("/Script/Engine.PrimitiveComponent"), 4);
    ClassIdMap.Add(TEXT("/Script/Engine.MeshComponent"), 5);
    ClassIdMap.Add(TEXT("/Script/Engine.StaticMeshComponent"), 6);
    ClassIdMap.Add(TEXT("/Script/Engine.SkeletalMeshComponent"), 7);
    ClassIdMap.Add(TEXT("/Script/Engine.Actor"), 10);
    ClassIdMap.Add(TEXT("/Script/Engine.Pawn"), 11);
    ClassIdMap.Add(TEXT("/Script/Engine.Character"), 12);
    ClassIdMap.Add(TEXT("/Script/Engine.Controller"), 13);
    ClassIdMap.Add(TEXT("/Script/Engine.PlayerController"), 14);
    ClassIdMap.Add(TEXT("/Script/Engine.AIController"), 15);
    ClassIdMap.Add(TEXT("/Script/Engine.GameMode"), 16);
    ClassIdMap.Add(TEXT("/Script/Engine.GameState"), 17);
    ClassIdMap.Add(TEXT("/Script/Engine.PlayerState"), 18);
    ClassIdMap.Add(TEXT("/Script/Engine.MovementComponent"), 20);
    ClassIdMap.Add(TEXT("/Script/Engine.CharacterMovementComponent"), 21);

    // Update next ID to avoid conflicts
    NextClassId = 100;
}

void USpacetimeDBCodeGenerator::Deinitialize()
{
    // Cleanup
    ClassIdMap.Empty();
    Super::Deinitialize();
}

bool USpacetimeDBCodeGenerator::GenerateRustClassRegistry(const FString& OutputPath)
{
    // Create output directory if needed
    FString Directory = FPaths::GetPath(OutputPath);
    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
    if (!PlatformFile.DirectoryExists(*Directory))
    {
        PlatformFile.CreateDirectoryTree(*Directory);
    }

    // Collect classes to register
    TArray<UClass*> RelevantClasses;
    GetAllRelevantClasses(RelevantClasses);

    // Generate file content
    TArray<FString> Lines;
    Lines.Add(TEXT("// AUTO-GENERATED FILE - DO NOT EDIT"));
    Lines.Add(TEXT("// Generated by SpacetimeDBCodeGenerator"));
    Lines.Add(TEXT(""));
    Lines.Add(TEXT("use spacetimedb::ReducerContext;"));
    Lines.Add(TEXT("use crate::object::{ObjectClass, ClassProperty};"));
    Lines.Add(TEXT("use crate::property::PropertyType;"));
    Lines.Add(TEXT(""));
    Lines.Add(TEXT("/// Registers all UE classes discovered at build time"));
    Lines.Add(TEXT("pub fn register_all_classes(ctx: &ReducerContext) {"));
    Lines.Add(TEXT("    log::info!(\"Registering UE classes from code-generated registry\");"));
    Lines.Add(TEXT(""));

    // First register core engine classes (these will have stable IDs 1-99)
    Lines.Add(TEXT("    // Register core engine classes"));
    Lines.Add(TEXT("    log::debug!(\"Registering core engine classes\");"));
    
    for (const auto& ClassPair : ClassIdMap)
    {
        UClass* Class = FindObject<UClass>(ANY_PACKAGE, *FPackageName::GetShortClassName(ClassPair.Key));
        if (Class)
        {
            FString Registration = GenerateClassRegistration(Class, ClassPair.Value);
            Lines.Add(FString::Printf(TEXT("    // Register %s"), *Class->GetName()));
            Lines.Add(Registration);
            Lines.Add(TEXT(""));
        }
    }
    
    Lines.Add(TEXT("    log::debug!(\"Registered {} core engine classes\", %d);"), ClassIdMap.Num());
    Lines.Add(TEXT(""));

    // Then register project-specific classes (these will have IDs 100+)
    Lines.Add(TEXT("    // Register project-specific classes"));
    Lines.Add(TEXT("    log::debug!(\"Registering project-specific classes\");"));
    
    int32 ProjectClassCount = 0;
    for (UClass* Class : RelevantClasses)
    {
        // Skip classes that are already in the core class map
        FString ClassPath = Class->GetPathName();
        if (ClassIdMap.Contains(ClassPath))
        {
            continue;
        }

        int32 ClassId = GenerateClassId(Class);
        FString Registration = GenerateClassRegistration(Class, ClassId);
        Lines.Add(FString::Printf(TEXT("    // Register %s"), *Class->GetName()));
        Lines.Add(Registration);
        Lines.Add(TEXT(""));
        ProjectClassCount++;
    }

    Lines.Add(TEXT("    log::debug!(\"Registered {} project-specific classes\", %d);"), ProjectClassCount);
    Lines.Add(TEXT("    log::info!(\"Registered {} total classes\", %d);"), ClassIdMap.Num() + ProjectClassCount);
    Lines.Add(TEXT("}"));
    Lines.Add(TEXT(""));

    // Add property registration function
    Lines.Add(TEXT("/// Registers properties for all UE classes discovered at build time"));
    Lines.Add(TEXT("pub fn register_all_properties(ctx: &ReducerContext) {"));
    Lines.Add(TEXT("    log::info!(\"Registering UE class properties from code-generated registry\");"));
    Lines.Add(TEXT(""));

    // First register properties for core engine classes
    Lines.Add(TEXT("    // Register properties for core engine classes"));
    Lines.Add(TEXT("    log::debug!(\"Registering core engine class properties\");"));
    
    for (const auto& ClassPair : ClassIdMap)
    {
        UClass* Class = FindObject<UClass>(ANY_PACKAGE, *FPackageName::GetShortClassName(ClassPair.Key));
        if (Class)
        {
            FString PropertyRegistrations = GeneratePropertyRegistrations(Class, ClassPair.Value);
            if (!PropertyRegistrations.IsEmpty())
            {
                Lines.Add(FString::Printf(TEXT("    // Register properties for %s"), *Class->GetName()));
                Lines.Add(PropertyRegistrations);
                Lines.Add(TEXT(""));
            }
        }
    }
    
    Lines.Add(TEXT(""));
    
    // Then register properties for project-specific classes
    Lines.Add(TEXT("    // Register properties for project-specific classes"));
    Lines.Add(TEXT("    log::debug!(\"Registering project-specific class properties\");"));
    
    for (UClass* Class : RelevantClasses)
    {
        // Skip classes that are already in the core class map
        FString ClassPath = Class->GetPathName();
        if (ClassIdMap.Contains(ClassPath))
        {
            continue;
        }

        int32 ClassId = GenerateClassId(Class);
        FString PropertyRegistrations = GeneratePropertyRegistrations(Class, ClassId);
        if (!PropertyRegistrations.IsEmpty())
        {
            Lines.Add(FString::Printf(TEXT("    // Register properties for %s"), *Class->GetName()));
            Lines.Add(PropertyRegistrations);
            Lines.Add(TEXT(""));
        }
    }

    Lines.Add(TEXT("    log::info!(\"Finished registering class properties\");"));
    Lines.Add(TEXT("}"));

    // Write to file
    return FFileHelper::SaveStringArrayToFile(Lines, *OutputPath);
}

bool USpacetimeDBCodeGenerator::GenerateRustComponentMappings(const FString& OutputPath)
{
    // Create output directory if needed
    FString Directory = FPaths::GetPath(OutputPath);
    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
    if (!PlatformFile.DirectoryExists(*Directory))
    {
        PlatformFile.CreateDirectoryTree(*Directory);
    }

    // Collect actor classes
    TArray<UClass*> ActorClasses;
    for (TObjectIterator<UClass> ClassIt; ClassIt; ++ClassIt)
    {
        UClass* Class = *ClassIt;
        if (Class->IsChildOf(AActor::StaticClass()) && 
            !Class->HasAnyClassFlags(CLASS_Abstract | CLASS_Deprecated | CLASS_NewerVersionExists) &&
            !Class->GetName().StartsWith(TEXT("SKEL_")) &&
            !Class->GetName().StartsWith(TEXT("REINST_")))
        {
            ActorClasses.Add(Class);
        }
    }

    // Generate file content
    TArray<FString> Lines;
    Lines.Add(TEXT("// AUTO-GENERATED FILE - DO NOT EDIT"));
    Lines.Add(TEXT("// Generated by SpacetimeDBCodeGenerator"));
    Lines.Add(TEXT(""));
    Lines.Add(TEXT("use spacetimedb::ReducerContext;"));
    Lines.Add(TEXT("use crate::actor::ActorId;"));
    Lines.Add(TEXT(""));
    Lines.Add(TEXT("/// Initializes default components for an actor based on its class"));
    Lines.Add(TEXT("pub fn initialize_components_for_class(ctx: &ReducerContext, actor_id: ActorId, class_id: u32) {"));
    Lines.Add(TEXT("    // Get class details from registry"));
    Lines.Add(TEXT("    if let Some(actor_class) = ctx.db.object_class().filter_by_class_id(&class_id).first() {"));
    Lines.Add(TEXT("        match actor_class.class_path.as_str() {"));

    // Generate component mappings for each class
    for (UClass* Class : ActorClasses)
    {
        TMap<FString, FString> Components;
        GetDefaultComponentsForClass(Class, Components);

        if (Components.Num() > 0)
        {
            FString ClassPath = FString::Printf(TEXT("/Script/%s.%s"), 
                *FPackageName::GetShortName(Class->GetOutermost()->GetName()),
                *Class->GetName());
            
            Lines.Add(FString::Printf(TEXT("            \"%s\" => {"), *ClassPath));
            Lines.Add(TEXT("                // Components for ") + Class->GetName());
            
            for (auto& Pair : Components)
            {
                int32 ComponentClassId = GenerateClassId(FindObject<UClass>(nullptr, *Pair.Value));
                Lines.Add(FString::Printf(TEXT("                add_component(ctx, actor_id, %d, \"%s\");"), 
                    ComponentClassId, *Pair.Key));
            }
            
            Lines.Add(TEXT("            },"));
        }
    }

    // Add default case and closing
    Lines.Add(TEXT("            _ => {"));
    Lines.Add(TEXT("                // Default case - check if this is an actor and add a root component"));
    Lines.Add(TEXT("                if actor_class.is_actor {"));
    Lines.Add(TEXT("                    add_component(ctx, actor_id, 3, \"RootComponent\"); // SceneComponent as root"));
    Lines.Add(TEXT("                }"));
    Lines.Add(TEXT("            }"));
    Lines.Add(TEXT("        }"));
    Lines.Add(TEXT("    }"));
    Lines.Add(TEXT("}"));

    // Helper function for adding components
    Lines.Add(TEXT(""));
    Lines.Add(TEXT("/// Helper function to add a component to an actor"));
    Lines.Add(TEXT("fn add_component(ctx: &ReducerContext, actor_id: ActorId, component_class_id: u32, component_name: &str) {"));
    Lines.Add(TEXT("    // Get the class to verify it exists and is a component"));
    Lines.Add(TEXT("    if let Some(component_class) = ctx.db.object_class().filter_by_class_id(&component_class_id).first() {"));
    Lines.Add(TEXT("        if !component_class.is_component {"));
    Lines.Add(TEXT("            log::warn!(\"Attempted to add non-component class {} as component\", component_class.class_name);"));
    Lines.Add(TEXT("            return;"));
    Lines.Add(TEXT("        }"));
    Lines.Add(TEXT("        "));
    Lines.Add(TEXT("        log::debug!(\"Adding component {} of type {} to actor {}\", "));
    Lines.Add(TEXT("                   component_name, component_class.class_name, actor_id);"));
    Lines.Add(TEXT("        "));
    Lines.Add(TEXT("        // Create the component"));
    Lines.Add(TEXT("        ctx.db.actor_component().insert(crate::actor::ActorComponent {"));
    Lines.Add(TEXT("            component_id: crate::actor::spawn::generate_actor_id(),"));
    Lines.Add(TEXT("            owner_actor_id: actor_id,"));
    Lines.Add(TEXT("            component_class_id,"));
    Lines.Add(TEXT("            component_name: component_name.to_string(),"));
    Lines.Add(TEXT("            is_active: true,"));
    Lines.Add(TEXT("        });"));
    Lines.Add(TEXT("    } else {"));
    Lines.Add(TEXT("        log::warn!(\"Attempted to add component with invalid class ID: {}\", component_class_id);"));
    Lines.Add(TEXT("    }"));
    Lines.Add(TEXT("}"));

    // Write to file
    return FFileHelper::SaveStringArrayToFile(Lines, *OutputPath);
}

void USpacetimeDBCodeGenerator::GetAllRelevantClasses(TArray<UClass*>& OutClasses)
{
    // Helper lambda to check if a class should be included
    auto ShouldIncludeClass = [](UClass* Class) {
        // Skip abstract, deprecated, and internal classes
        if (Class->HasAnyClassFlags(CLASS_Abstract | CLASS_Deprecated | CLASS_NewerVersionExists))
            return false;

        // Skip skeleton and reinstanced classes
        if (Class->GetName().StartsWith(TEXT("SKEL_")) || Class->GetName().StartsWith(TEXT("REINST_")))
            return false;

        // Include UObject and its important descendants
        return Class->IsChildOf(UObject::StaticClass()) && 
               (Class->IsChildOf(AActor::StaticClass()) || 
                Class->IsChildOf(UActorComponent::StaticClass()) ||
                Class == UObject::StaticClass());
    };

    // Collect all relevant classes
    for (TObjectIterator<UClass> ClassIt; ClassIt; ++ClassIt)
    {
        UClass* Class = *ClassIt;
        if (ShouldIncludeClass(Class))
        {
            OutClasses.Add(Class);
        }
    }

    // Sort classes to ensure parent classes are registered first
    OutClasses.Sort([](UClass& A, UClass& B) {
        // If B inherits from A, A should come first
        if (B.IsChildOf(&A))
            return true;
        // If A inherits from B, B should come first
        if (A.IsChildOf(&B))
            return false;
        // Otherwise sort by name for stable ordering
        return A.GetName() < B.GetName();
    });
}

FString USpacetimeDBCodeGenerator::GenerateClassRegistration(UClass* Class, int32 ClassId)
{
    // Get parent class ID
    int32 ParentClassId = 0;
    if (Class->GetSuperClass())
    {
        FString ParentPath = FString::Printf(TEXT("/Script/%s.%s"), 
            *FPackageName::GetShortName(Class->GetSuperClass()->GetOutermost()->GetName()),
            *Class->GetSuperClass()->GetName());
        
        // Look up parent ID or generate one
        if (!ClassIdMap.Contains(ParentPath))
        {
            ParentClassId = GenerateClassId(Class->GetSuperClass());
        }
        else
        {
            ParentClassId = ClassIdMap[ParentPath];
        }
    }

    // Get class attributes
    bool IsActor = Class->IsChildOf(AActor::StaticClass());
    bool IsComponent = Class->IsChildOf(UActorComponent::StaticClass());
    bool Replicates = Class->HasMetaData(TEXT("IsSpatiallyReplicatable")) || 
                      (IsActor && Class->GetDefaultObject<AActor>()->GetIsReplicated());

    // Get class path
    FString ClassPath = FString::Printf(TEXT("/Script/%s.%s"), 
        *FPackageName::GetShortName(Class->GetOutermost()->GetName()),
        *Class->GetName());

    // Generate Rust code
    FString Code = FString::Printf(TEXT("    ctx.db.object_class().insert(ObjectClass {\n"));
    Code += FString::Printf(TEXT("        class_id: %d,\n"), ClassId);
    Code += FString::Printf(TEXT("        class_name: \"%s\".to_string(),\n"), *Class->GetName());
    Code += FString::Printf(TEXT("        class_path: \"%s\".to_string(),\n"), *ClassPath);
    Code += FString::Printf(TEXT("        parent_class_id: %d,\n"), ParentClassId);
    Code += FString::Printf(TEXT("        replicates: %s,\n"), Replicates ? TEXT("true") : TEXT("false"));
    Code += FString::Printf(TEXT("        is_actor: %s,\n"), IsActor ? TEXT("true") : TEXT("false"));
    Code += FString::Printf(TEXT("        is_component: %s,\n"), IsComponent ? TEXT("true") : TEXT("false"));
    Code += FString::Printf(TEXT("    });"));

    return Code;
}

FString USpacetimeDBCodeGenerator::GeneratePropertyRegistrations(UClass* Class, int32 ClassId)
{
    TArray<FString> PropertyLines;

    // Helper to map UE property type to SpacetimeDB property type
    auto MapPropertyType = [](FProperty* Property) -> FString {
        if (Property->IsA<FBoolProperty>())
            return TEXT("PropertyType::Bool");
        else if (Property->IsA<FIntProperty>() || Property->IsA<FInt64Property>())
            return TEXT("PropertyType::Int");
        else if (Property->IsA<FFloatProperty>() || Property->IsA<FDoubleProperty>())
            return TEXT("PropertyType::Float");
        else if (Property->IsA<FStrProperty>() || Property->IsA<FNameProperty>() || Property->IsA<FTextProperty>())
            return TEXT("PropertyType::String");
        else if (Property->IsA<FStructProperty>())
        {
            FStructProperty* StructProp = CastField<FStructProperty>(Property);
            FString StructName = StructProp->Struct->GetName();
            
            if (StructName == TEXT("Vector"))
                return TEXT("PropertyType::Vector");
            else if (StructName == TEXT("Rotator") || StructName == TEXT("Quat"))
                return TEXT("PropertyType::Rotator");
            else if (StructName == TEXT("Transform"))
                return TEXT("PropertyType::Transform");
            else
                return TEXT("PropertyType::Struct");
        }
        else if (Property->IsA<FObjectProperty>() || Property->IsA<FClassProperty>())
            return TEXT("PropertyType::ObjectReference");
        else if (Property->IsA<FArrayProperty>())
            return TEXT("PropertyType::Array");
        else if (Property->IsA<FMapProperty>())
            return TEXT("PropertyType::Map");
        else if (Property->IsA<FSetProperty>())
            return TEXT("PropertyType::Set");
            
        return TEXT("PropertyType::Unknown");
    };

    // Iterate properties that should be registered
    for (TFieldIterator<FProperty> PropIt(Class, EFieldIteratorFlags::ExcludeSuper); PropIt; ++PropIt)
    {
        FProperty* Property = *PropIt;
        
        // Skip editor-only and transient properties
        if (Property->HasAnyPropertyFlags(CPF_EditorOnly | CPF_Transient | CPF_DuplicateTransient))
            continue;
            
        // Only register properties that are meant to be replicated or serialized
        if (Property->HasAnyPropertyFlags(CPF_Net | CPF_RepSkip | CPF_SaveGame | CPF_Config))
        {
            bool IsReplicated = Property->HasAnyPropertyFlags(CPF_Net) && !Property->HasAnyPropertyFlags(CPF_RepSkip);
            bool IsReadonly = !Property->HasAnyPropertyFlags(CPF_Edit);
            FString PropertyType = MapPropertyType(Property);
            
            FString PropLine = FString::Printf(TEXT("    ctx.db.class_property().insert(ClassProperty {\n"));
            PropLine += FString::Printf(TEXT("        class_id: %d,\n"), ClassId);
            PropLine += FString::Printf(TEXT("        property_name: \"%s\".to_string(),\n"), *Property->GetName());
            PropLine += FString::Printf(TEXT("        property_type: %s,\n"), *PropertyType);
            PropLine += FString::Printf(TEXT("        replicated: %s,\n"), IsReplicated ? TEXT("true") : TEXT("false"));
            PropLine += FString::Printf(TEXT("        readonly: %s,\n"), IsReadonly ? TEXT("true") : TEXT("false"));
            PropLine += FString::Printf(TEXT("    });"));
            
            PropertyLines.Add(PropLine);
        }
    }

    return FString::Join(PropertyLines, TEXT("\n"));
}

void USpacetimeDBCodeGenerator::GetDefaultComponentsForClass(UClass* Class, TMap<FString, FString>& OutComponents)
{
    // Only process actor classes
    if (!Class->IsChildOf(AActor::StaticClass()))
        return;
        
    // Get components from the actor's default object
    AActor* DefaultActor = Class->GetDefaultObject<AActor>();
    if (!DefaultActor)
        return;
        
    // Get all default scene components (only process root and direct children for simplicity)
    USceneComponent* RootComponent = DefaultActor->GetRootComponent();
    if (RootComponent)
    {
        // Add root component
        OutComponents.Add(RootComponent->GetName(), RootComponent->GetClass()->GetPathName());
        
        // Add direct children
        TArray<USceneComponent*> ChildComponents;
        RootComponent->GetChildrenComponents(false, ChildComponents);
        
        for (USceneComponent* ChildComp : ChildComponents)
        {
            if (ChildComp)
            {
                OutComponents.Add(ChildComp->GetName(), ChildComp->GetClass()->GetPathName());
            }
        }
    }
    
    // Get non-scene components
    TArray<UActorComponent*> Components;
    DefaultActor->GetComponents(Components);
    
    for (UActorComponent* Component : Components)
    {
        if (Component && !Component->IsA<USceneComponent>())
        {
            OutComponents.Add(Component->GetName(), Component->GetClass()->GetPathName());
        }
    }
}

int32 USpacetimeDBCodeGenerator::GenerateClassId(UClass* Class)
{
    if (!Class)
        return 0;
        
    // Get class path
    FString ClassPath = FString::Printf(TEXT("/Script/%s.%s"), 
        *FPackageName::GetShortName(Class->GetOutermost()->GetName()),
        *Class->GetName());
    
    // If already mapped, return existing ID
    if (ClassIdMap.Contains(ClassPath))
    {
        return ClassIdMap[ClassPath];
    }
    
    // Generate new ID and store in map
    int32 ClassId = NextClassId++;
    ClassIdMap.Add(ClassPath, ClassId);
    return ClassId;
} 